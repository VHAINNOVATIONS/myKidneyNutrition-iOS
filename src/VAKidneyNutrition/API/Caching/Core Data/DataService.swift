//
//  DataService.swift
//  VAKidneyNutrition
//
//  Created by TCCODER on 12/21/17.
//  Modified by TCCODER on 5/26/18.
//  Copyright Â© 2017 Topcoder. All rights reserved.
//

import Foundation
import CoreData

/// queue for synchronizing data updates
private let cacheQueue : DispatchQueue = DispatchQueue(label: "cacheQueue", attributes: [])

/// Represents the data service error domain.
public let DataServiceErrorDomain = "DataServiceErrorDomain"

/**
 * Represents the core data entity protocol. For example:
 * ````
 * class User: CoreDataEntity {
 *  ...
 * }
 * ````
 *
 * - author: TCCODER
 * - version: 1.0
 */
public protocol CoreDataEntity : class {

    associatedtype Entity: CoreDataEntityBridge

    /// Convert Managed Object (MO) to Entity.
    /// If object depends on other MO, then it must assign all that properties using cascade conversion (if true),
    /// but for all that objects toEntity() must be called with cascade=false. If that object have inverse references,
    /// then if object is descendant, then update "parent" reference to self, it not ancestor, then do nothing.
    ///
    /// - Parameter cascade: flag: true - will update desendant relatations to other Entities that have theirself MO.
    /// - Parameter up: flag: true - will update parent relatations to other Entities that have theirself MO.
    /// - Returns: the Entity instance
    func toEntity() -> Entity

    /// Fill data from model object.
    ///
    /// - Parameters:
    ///   - object: the value object
    ///   - relatedObjects: the related objects
    func fillDataFrom(_ object: Entity, relatedObjects: Any?)
}

/**
 * Helpful extension
 *
 * - author: TCCODER
 * - version: 1.0
 */
extension NSManagedObject {

    /// Represents the entity name static property.
    open class var entityName : String {
        return NSStringFromClass(self).components(separatedBy: ".").last ?? ""
    }
}

/**
 * Represents the core data entity bridge protocol.
 *
 * - author: TCCODER
 * - version: 1.0
 */
public protocol CoreDataEntityBridge {

    /// the ID of the model object
    var id: String { get }

    /// flag: true - if object is deleted/archived
    var deletedLocally: Bool { get set }

    // The ObjectID of the CoreData object we saved to or loaded from
    var managedObjectID: NSManagedObjectID? { get set }

    /// the date of data retrieval
    var retrievalDate: Date { get set }
}

/// Represents the data service failure closure type.
public typealias GeneralFailureBlock = (Error) -> Void

/**
 * Error generated by DataService
 *
 * - author: TCCODER
 * - version: 1.0
 */
struct DataServiceError: Error {
    let error: Error?
    let message: String
}

/**
 * Represents the data service class. This is the base class for all core data related classes.
 *
 * - author: TCCODER
 * - version: 1.1
 *
 * changes:
 * 1.1:
 * - Swift 4 change
 */
class DataService<ManagedEntity, Entity>  where
    ManagedEntity: NSManagedObject,
ManagedEntity: CoreDataEntity, ManagedEntity.Entity == Entity {

    /// the managed object context
    fileprivate var context: NSManagedObjectContext! {
        return CoreDataStack.shared.viewContext
    }

    /**
     Initialize new instance.

     - returns: The new created instance.
     */
    public init() {
    }

    // MARK: - Common methods

    /// Gets the corresponding managed objects
    ///
    /// - Parameter array: array of entities
    /// - Returns: array of managed objects
    func toManaged(array: [Entity]) -> [ManagedEntity] {
        let context = self.context!
        return array.compactMap { $0.managedObjectID }.map { context.object(with: $0) as! ManagedEntity }
    }

    /**
     Get all objects

     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func getAll(_ success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {
        get(withPredicate: nil, success, failure: failure)
    }

    /**
     Get objects with predicate

     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func get(withPredicate predicate: NSPredicate?, _ success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {

        // create the request
        let fetchRequest = NSFetchRequest<ManagedEntity>(entityName: ManagedEntity.entityName)
        fetchRequest.returnsObjectsAsFaults = false
        fetchRequest.predicate = predicate
        fetchRequest.sortDescriptors = [NSSortDescriptor.init(key: "id", ascending: true)]

        get(withRequest: fetchRequest, success, failure: failure)
    }

    /// Get objects with request
    ///
    /// - Parameters:
    ///   - fetchRequest: NSFetchRequest
    ///   - success: the success callback
    ///   - failure: the failure callback to invoke when an error occurred
    func get(withRequest fetchRequest: NSFetchRequest<ManagedEntity>, _ success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {
        // execute the fetch
        executeFetch(fetchRequest, transform: { (managed: ManagedEntity) -> Entity in
            var object = managed.toEntity()
            object.managedObjectID = managed.objectID           // Update managedObjectID for later update operations
            return object
        }, success: success, failure: failure)
    }

    /**
     Get objects with predicate

     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func getMO(withPredicate predicate: NSPredicate?, _ success: @escaping ([ManagedEntity]) -> (), failure: @escaping GeneralFailureBlock) {

        // create the request
        let fetchRequest = NSFetchRequest<ManagedEntity>(entityName: ManagedEntity.entityName)
        fetchRequest.returnsObjectsAsFaults = false
        fetchRequest.predicate = predicate
        fetchRequest.sortDescriptors = [NSSortDescriptor.init(key: "id", ascending: true)]

        // execute the fetch
        executeFetch(fetchRequest, success: success, failure: failure)
    }

    /**
     Insert new objects

     - parameter objects: the objects to insert
     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func insert(_ objects: [Entity], relatedObjects: NSManagedObject? = nil, success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {

        // transform
        let transform = { (item: Entity, managed: ManagedEntity) -> () in
            managed.fillDataFrom(item, relatedObjects: relatedObjects?.in())
        }
        // insertion
        self.insertObjects(objects, transform: transform, success: success, failure: failure)
    }

    /// Insert new objects
    ///
    /// - Parameters:
    ///   - objects: the objects to insert
    ///   - relatedObjects: the related object that are not presented in model class
    ///   - success: the success callack
    ///   - failure: the failure callback to invoke when an error occurred
    func insert(_ objects: [Entity], relatedObjects: [NSManagedObject], success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {

        // transform
        let transform = { (item: Entity, managed: ManagedEntity) -> () in
            managed.fillDataFrom(item, relatedObjects: relatedObjects.map { $0.in() })
        }
        // insertion
        self.insertObjects(objects, transform: transform, success: success, failure: failure)
    }

    /**
     Update or insert objects

     - parameter objects: the objects
     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func upsert(_ objects: [Entity], relatedObjects: [NSManagedObject]? = nil, success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {
        if objects.isEmpty { success([]); return }

        self.get(withPredicate: self.createStringArrayPredicate("id", value: objects.map { $0.id }), { (oldObjects) in

            var objectsToInsert = [Entity]()
            var objectsToUpdate = [Entity]()
            for object in objects {
                var object = object
                if let oldObject = oldObjects.filter({$0.id == object.id}).first {
                    object.managedObjectID = oldObject.managedObjectID
                    objectsToUpdate.append(object)
                }
                else {
                    objectsToInsert.append(object)
                }
            }
            DispatchQueue.main.async {
                self.insert(objectsToInsert, relatedObjects: relatedObjects ?? [], success: { insertedObjects in
                    self.update(objectsToUpdate, relatedObjects: relatedObjects ?? [], success: {
                        success(insertedObjects + objectsToUpdate)
                    }, failure: failure)
                }, failure: failure)
            }
        }, failure: failure)
    }

    /**
     Update objects

     - parameter objects: the objects
     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func update(_ objects: [Entity], relatedObjects: NSManagedObject? = nil, success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {

        // transform
        let transform = { (item: Entity, managed: ManagedEntity) -> () in
            managed.fillDataFrom(item, relatedObjects: relatedObjects?.in())
        }
        // update
        self.updateObjects(objects, transform: transform, success: success, failure: failure)
    }

    /**
     Update objects

     - parameter objects: the objects
     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func update(_ objects: [Entity], relatedObjects: [NSManagedObject], success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {

        // transform
        let transform = { (item: Entity, managed: ManagedEntity) -> () in
            managed.fillDataFrom(item, relatedObjects: relatedObjects.map { $0.in() })
        }
        // update
        self.updateObjects(objects, transform: transform, success: success, failure: failure)
    }

    /**
     Delete objects

     - parameter objects: the objects
     - parameter success: the success callback
     - parameter failure: the failure callback to invoke when an error occurred
     */
    func delete(_ objects: [Entity], success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {
        // delete
        self.removeInstances(objects, success: success, failure: failure)
    }

    /// Replaces the given object with newObject
    ///
    /// - Parameters:
    ///   - object: the object to replace
    ///   - newObject: new object
    ///   - success: the success callback
    ///   - failure: the failure callback to invoke when an error occurred
    func replace(_ object: Entity?, withNew newObject: Entity, success: @escaping (Entity) -> (), failure: @escaping GeneralFailureBlock) {
        let insertCallback = {
            self.insert([newObject], success: { items in
                success(items.first!)
            }, failure: failure)
        }
        if let object = object {
            self.delete([object], success: {
                insertCallback()
            }, failure: failure)
        }
        else {
            insertCallback()
        }
    }

    /// Replaces the given objects with newObjects
    ///
    /// - Parameters:
    ///   - objects: the objects to replace
    ///   - newObjects: new objects
    ///   - relatedObjects: the related objects
    ///   - success: the success callback
    ///   - failure: the failure callback to invoke when an error occurred
    func replace(_ objects: [Entity], withNew newObjects: [Entity], relatedObjects: Any? = nil, success: @escaping ([Entity]) -> (), failure: @escaping GeneralFailureBlock) {
        let insertCallback = {
            // transform
            let transform = { (item: Entity, managed: ManagedEntity) -> () in
                managed.fillDataFrom(item, relatedObjects: relatedObjects)
            }
            // insertion
            self.insertObjects(newObjects, transform: transform, success: success, failure: failure)
        }
        if objects.isEmpty {
            insertCallback()
        }
        else {
            self.delete(objects, success: {
                insertCallback()
            }, failure: failure)
        }
    }

    // MARK:- Fetch

    /**
     Executes a fetch request with transform, success and failure parameters.

     - parameter fetchRequest: The fetch request parameter.
     - parameter transform:    The transform parameter.
     - parameter success:      The success parameter.
     - parameter failure:      The failure parameter.
     */
    func executeFetch<M : NSManagedObject, E>(_ fetchRequest: NSFetchRequest<M>,
                                              transform: @escaping (M) -> E, success: @escaping ([E]) -> (), failure: @escaping GeneralFailureBlock) {
        // get the data
        do {
            let items = try self.context.fetch(fetchRequest)

            // cast them
            let castedItems = items

            // map them
            let mappedItems = castedItems.map(transform)

            success(mappedItems)

        } catch let error {
            // failure in fetch
            let customError = createFetchingError(error, fetchRequest.entityName)
            failure(customError)
        }
    }

    /**
     Executes a fetch request, success and failure parameters.

     - parameter fetchRequest: The fetch request parameter.
     - parameter success:      The success parameter.
     - parameter failure:      The failure parameter.
     */
    func executeFetch<M : NSManagedObject>(_ fetchRequest: NSFetchRequest<M>, success: @escaping ([M]) -> (), failure: @escaping GeneralFailureBlock) {
        // get the data
        do {
            let items = try self.context.fetch(fetchRequest)

            // cast them
            let castedItems = items

            // inform the user
            success(castedItems)
        } catch let error {
            // failure in fetch
            let customError = createFetchingError(error, fetchRequest.entityName)
            failure(customError)
        }
    }

    fileprivate func createFetchingError(_ error: Error?, _ entityName: String?) -> Error {
        return DataServiceError(error: error,
                                message: "An error occurred while fetching '\(entityName ?? "")'.")
    }

    /**
     Executes a fetch request with transform, success and failure parameters.

     - parameter fetchRequest: The fetch request parameter.
     - parameter transform:    The transform parameter.
     - parameter success:      The success parameter.
     - parameter failure:      The failure parameter.
     */
    func executeFetchOptional<M : NSManagedObject, E>(_ fetchRequest: NSFetchRequest<M>,
                                                      transform: @escaping (M) -> E?, success: @escaping ([E]) -> (), failure: @escaping GeneralFailureBlock) {
        // get the data
        do {
            let items = try self.context.fetch(fetchRequest)

            // cast them
            let castedItems = items

            // map them
            let mappedItemsOptional = castedItems.map(transform)

            let mappedItems = mappedItemsOptional.filter({$0 != nil}).map({$0!})

            success(mappedItems)
        } catch let error {
            // failure in fetch
            let customError = createFetchingError(error, fetchRequest.entityName)
            failure(customError)
        }
    }

    // MARK:- Insertion

    /**
     Insert objects with transform, success and failure parameters.

     - parameter objects:   The objects parameter.
     - parameter transform: The transform parameter.
     - parameter success:   The success parameter.
     - parameter failure:   The failure parameter.
     */
    func insertObjects<M: NSManagedObject, E : CoreDataEntityBridge>(_ objects: [E],
                                                                     transform: @escaping (E, M) ->  (), success: @escaping ([E]) -> (), failure: @escaping GeneralFailureBlock) where M: CoreDataEntity {

        let creator = { (entity: E, context: NSManagedObjectContext) -> M in

            let managedItem: AnyObject = NSEntityDescription.insertNewObject(forEntityName: M.entityName,
                                                                             into: context)
            assert(managedItem is M, "Created item should be of type '\(M.self)'")
            let castedManagedItem = managedItem as! M

            return castedManagedItem
        }

        insertObjectsCommon(objects, managedCreator: creator, transform: transform, success: success, failure: failure)
    }

    /**
     Core data entity bridge managed creator, transform, success and failure.

     - parameter objects:        The objects parameter.
     - parameter managedCreator: The managed creator parameter.
     - parameter transform:      The transform parameter.
     - parameter success:        The success parameter.
     - parameter failure:        The failure parameter.
     */
    func insertObjectsCommon<M : NSManagedObject, E : CoreDataEntityBridge >(
        _ objects: [E],
        managedCreator: @escaping (E, NSManagedObjectContext) -> M, transform: @escaping (E, M) -> (),
        success: @escaping ([E]) -> (),
        failure: @escaping GeneralFailureBlock) where M: CoreDataEntity {

        cacheQueue.sync(){
            var insertedManaged = [M]()
            // loop over the items and insert them to the context
            for object in objects {

                // create new entity
                let managedItem = managedCreator(object, self.context)

                // transform
                transform(object, managedItem)

                insertedManaged.append(managedItem)
            }

            // save
            self.saveContext({ () -> () in
                var insertedObjects = [E]()
                for i in 0..<insertedManaged.count {
                    let managedItem = insertedManaged[i]
                    var item = objects[i]

                    item.managedObjectID = managedItem.objectID
                    insertedObjects.append(item)
                }

                success(insertedObjects)
            }, failure: failure)
        }
    }

    // MARK:- Update

    /**
     Update objects with transform, success and failure parameters.

     - parameter objects:   The objects parameter.
     - parameter transform: The transform parameter.
     - parameter success:   The success parameter.
     - parameter failure:   The failure parameter.
     */
    func updateObjects<M: NSManagedObject, E : CoreDataEntityBridge>(_ objects: [E],
                                                                     transform: @escaping (E, M) -> (), success: @escaping () -> (), failure: @escaping GeneralFailureBlock) where M: CoreDataEntity {
        cacheQueue.sync(){
            // loop over the items and update them in the context
            for object in objects {
                if let objectID = object.managedObjectID {
                    // create new entity
                    let item = self.context.object(with: objectID);
                    assert(item is M, "Retrieved item should be of type '\(M.self)'")
                    let castedItem = item as! M

                    // transform
                    transform(object, castedItem)

                } else {
                    self.executeOnMain {
                        failure("Cannot save object with no ID. \(object)")
                    }
                    return
                }
            }

            // save
            self.saveContext(success, failure: failure)
        }
    }

    // MARK:- Deletion

    /**
     Remove all instances with success and failure parameters.

     - parameter entityName: The entity name parameter.
     - parameter success:    The success parameter.
     - parameter failure:    The failure parameter.
     */
    open func removeAllInstances(_ entityName: String, success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {
        removeInstancesOfRequest(NSFetchRequest(entityName: entityName), success: success, failure: failure)
    }

    /**
     Remove instances of request with success and failure parameters.

     - parameter request: The request parameter.
     - parameter success: The success parameter.
     - parameter failure: The failure parameter.
     */
    func removeInstancesOfRequest(_ request: NSFetchRequest<NSFetchRequestResult>, success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {
        cacheQueue.sync() {
            request.includesPropertyValues = false
            // get the data
            do {
                let items = try self.context.fetch(request) as! [NSManagedObject]
                // delete the items
                for item in items {
                    self.context.delete(item)
                }

                // save
                self.saveContext(success, failure: failure)
            } catch let error{
                // failure in fetch
                self.executeOnMain {
                    failure(error)
                }
            }
        }
    }

    /**
     Remove instances with success and failure parameters.

     - parameter objects: The objects parameter.
     - parameter success: The success parameter.
     - parameter failure: The failure parameter.
     */
    func removeInstances<E : CoreDataEntityBridge>(_ objects: [E], success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {
        cacheQueue.sync() {
            // loop over the items and delete them in the context
            for object in objects {
                if let objectID = object.managedObjectID {
                    // create new entity
                    let managedItem = self.context.object(with: objectID);
                    self.context.delete(managedItem)

                } else {
                    self.executeOnMain {
                        failure("Cannot delete object with no ID. \(object)")
                    }
                    return
                }
            }
            // save
            self.saveContext(success, failure: failure)
        }
    }

    // MARK:- Save Context

    /**
     Saves the managed object context with sucess and failure parameters.

     - parameter success: The success parameter.
     - parameter failure: The failure parameter.
     */
    func saveContext(_ success: @escaping () -> (), failure: @escaping GeneralFailureBlock) {
        // save
        do {
            try self.context.save()
            self.executeOnMain {
                // inform the user the operation succeeded
                success()
            }
        } catch let error {
            // failure in fetch
            self.executeOnMain {
                failure(error)
            }
        }
    }

    /**
     Execute the block on the main thread.

     - parameter block: The block parameter.
     */
    func executeOnMain(block: @escaping () -> ()) {
        DispatchQueue.main.async {
            block()
        }
    }

    // MARK: - predicates

    /**
     Create string predicate with name and value.

     - parameter name:  The name parameter.
     - parameter value: The value parameter.

     - returns: The created predicate.
     */
    func createStringPredicate(_ name: String, value: String) -> NSPredicate {
        return NSPredicate(format: "%K = %@", name, value)
    }

    /**
     Create integer predicate with name and value.

     - parameter name:  The name parameter.
     - parameter value: The value parameter.

     - returns: The created predicate.
     */
    func createIntPredicate(_ name: String, value: Int) -> NSPredicate {
        return NSPredicate(format: "%K == %d", name, value)
    }

    /**
     Create boolean predicate with name and value.

     - parameter name:  The name parameter.
     - parameter value: The value parameter.

     - returns: The created predicate.
     */
    func createBoolPredicate(_ name: String, value: Bool) -> NSPredicate {
        return NSPredicate(format: "%K == %d", name, value ? 1 : 0)
    }

    /**
     Create integer array predicate value.

     - parameter name:  The name parameter.
     - parameter value: The value parameter.

     - returns: The created predicate.
     */
    func createIntArrayPredicate(_ name: String, value: [Int]) -> NSPredicate {
        return NSPredicate(format: "%K IN %@", name, value)
    }

    /**
     Create string array predicate value.

     - parameter name:  the name parameter
     - parameter value: the value parameter

     - returns: the created predicate
     */
    func createStringArrayPredicate(_ name: String, value: [String]) -> NSPredicate {
        return NSPredicate(format: "%K IN %@", name, value)
    }

    /// Create date inequality predicate (greater or equal)
    ///
    /// - Parameters:
    ///   - name: the name parameter
    ///   - date: the date
    /// - Returns: the created predicate
    func createDateGreaterOrEqualToPredicate(_ name: String, date: Date) -> NSPredicate {
        return NSPredicate(format: "%K >= %@", name, date as NSDate)
    }

    /// Create date inequality predicate (less or equal)
    ///
    /// - Parameters:
    ///   - name: the name parameter
    ///   - date: the date
    /// - Returns: the created predicate
    func createDateLessOrEqualToPredicate(_ name: String, date: Date) -> NSPredicate {
        return NSPredicate(format: "%K <= %@", name, date as NSDate)
    }

    /// Create nil predicate
    ///
    /// - Parameter name: the name parameter
    /// - Returns: the created predicate
    func createNilPredicate(_ name: String) -> NSPredicate {
        return NSPredicate(format: "%K = nil", name)
    }

    /**
     Check if at least one object is expired

     - parameter objects:       the objects
     - parameter timeInterval: the caching time

     - returns: true - if the object is expired, false - else
     */
    func isExpired<T: CoreDataEntityBridge>(_ objects: [T], timeInterval: TimeInterval) -> Bool {
        if objects.isEmpty {
            return true
        }
        var isExpired = false
        for object in objects {
            if self.isExpired(object, timeInterval: timeInterval) {
                isExpired = true
                break
            }
        }
        return isExpired
    }

    /// Check if at least one object is expired
    ///
    /// - Parameters:
    ///   - objects: the objects
    ///   - timeInterval: the caching time
    /// - Returns: true - if the object is expired, false - else
    func isExpired<T: CacheableObject>(_ objects: [T], timeInterval: TimeInterval?) -> Bool {
        if objects.isEmpty {
            return true
        }
        var isExpired = false
        if let timeInterval = timeInterval {
            for object in objects {
                if self.isExpired(object.retrievalDate, timeInterval: timeInterval) {
                    isExpired = true
                    break
                }
            }
        }
        return isExpired
    }

    /// Check if the object is expired
    ///
    /// - Parameters:
    ///   - object: the object
    ///   - timeInterval: the caching time
    /// - Returns: true - if the object is expired, false - else
    func isExpired<T: CacheableObject>(_ object: T?, timeInterval: TimeInterval) -> Bool {
        guard let object = object else {
            return true
        }
        return self.isExpired(object.retrievalDate, timeInterval: timeInterval)
    }

    /**
     Check if the object is expired

     - parameter object:       the object
     - parameter timeInterval: the caching time

     - returns: true - if the object is expired, false - else
     */
    func isExpired(_ object: CoreDataEntityBridge, timeInterval: TimeInterval) -> Bool {
        return isExpired(object.retrievalDate, timeInterval: timeInterval)
    }

    /**
     Check if given retrieval date is expired

     - parameter date:         the date
     - parameter timeInterval: the caching time

     - returns: true - if the date is expired, false - else
     */
    func isExpired(_ date: Date, timeInterval: TimeInterval) -> Bool {
        let calendar = Calendar.current
        let difference = (calendar as NSCalendar).components(.second, from: date, to: Date(), options: [])
        return Double(difference.second!) > timeInterval
    }
}

